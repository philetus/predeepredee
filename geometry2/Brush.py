import pango

class Brush( object ):
    """brush to draw to canvas

       a path can be generated by using move_*() and path_*() commands

       move_to() and path_to() take absolute coordinates from the upper
       left corner of the canvas, and move_by() and path_by() take coordinates
       relative to the current brush position

       moving brush after path segments have been drawn initiates a new subpath

       three types of paths can be generated depending on which args are given:
         > a straight path from the current brush location to the given coords
         > a bezier curve from the current brush coords to the given coords,
           using two additional control point coords to control the curvature
         > a text path from a string along the straight or curved path given

       generated paths can be stroked with the current brush color, size and
       shape using stroke(), and closed paths can be filled with the current
       brush color using fill()

       the gtk/cairo brush implementation takes a cairo context as an init
       argument and maps brush methods and properties to cairo context methods
    """

    # brush shape flags
    SQUARE = 0
    ROUND = 1

    def __init__(self, context, size):
        # cairo context to draw to
        self._context = context 

        # pango text layout for drawing text paths
        self._layout = self._context.create_layout()
        self._font = pango.FontDescription( "sans 16" )
        self._layout.set_font_description( self._font )

        # offsets for masked origins
        self._offset_stack = [((0, 0), size)] 
        self._offset = (0, 0)
        self._mask_size = size

    def move_to(self, x, y):
        """move brush to given coordinates
        """
        self._context.move_to( self._offset[0] + x, self._offset[1] + y )

    def move_by(self, dx=0.0, dy=0.0):
        """move brush relative to current position by given delta coordinates
        """
        self._context.rel_move_to(dx, dy)

    def path_to(self, x, y, c0_x=None, c0_y=None, c1_x=None, c1_y=None,
                text=None):
        """generate path using absolute coordinates

           > if only x and y coords are given generates a straight path
           > if control points are given generates a bezier curve
           > if text string is given generates font path along straight
             or curved line
        """                    
        # font paths not implemented yet
        if text is not None:
            raise NotImplementedError( "font paths not implemented yet" )

        # if control points given generate bezier curve
        if self._vet_control_points(c0_x, c0_y, c1_x, c1_y):
            self._context.curve_to(self._offset[0] + c0_x,
                                   self._offset[1] + c0_y,
                                   self._offset[0] + c1_x,
                                   self._offset[1] + c1_y,
                                   self._offset[0] + x,
                                   self._offset[1] + y)

        # otherwise generate sraight path
        else:
            self._context.line_to( self._offset[0] + x, self._offset[1] + y )

    def path_by(self, dx, dy, c0_dx=None, c0_dy=None, c1_dx=None, c1_dy=None,
                text=None):
        """generate path using relative coordinates

           > if only dx and dy coords are given generates a straight path
           > if control points are given generates a bezier curve
           > if text string is given generates font path along straight
             or curved line
        """
        # font paths not implemented yet
        if text is not None:
            raise NotImplementedError("font paths not implemented yet")

        # if control points given generate bezier curve
        if self._vet_control_points(c0_dx, c0_dy, c1_dx, c1_dy):
            self._context.rel_curve_to(c0_dx, c0_dy, c1_dx, c1_dy, dx, dy)

        # otherwise generate sraight path
        else:
            self._context.rel_line_to(dx, dy)

    def close_path( self ):
        """joins beginning and end of current subpath so that they will be
           stroked smoothly, adding a new path segment if the first and
           last points are not the same
        """
        self._context.close_path()

    def text_path( self ):
        """add current text to path starting at upper left
        """
        self._context.layout_path( self._layout )
        

    def fill_path( self ):
        """fill current path with current brush settings
        """
        self._context.fill_preserve()

    def stroke_path( self ):
        """stroke current path with current brush settings
        """
        self._context.stroke_preserve()

    def clear_path( self ):
        """clear current path
        """
        self._context.new_path()

    def push_mask(self, x0, y0, x1, y1):
        """reset origin to x0, y0 and limit drawing to within rectangular area
        """
        # push current context state onto stack
        self._context.save()

        # create rectangular path
        self.move_to(x0, y0)
        self.path_to(x0, y1)
        self.path_to(x1, y1)
        self.path_to(x1, y0)
        self.close_path()

        # create mask from path
        self._context.clip()

        # push new origin onto offset stack
        self._offset_stack.append( ((x0, y0), (x1, y1)) )
        self._offset = self._offset[0] + x0, self._offset[1] + y0
        self._mask_size = abs(x1 - x0), abs(y1 - y0)

    def pop_mask( self ):
        """remove most recently pushed mask from brush drawing area
        """
        # check that there is a mask to pop
        if len( self._offset_stack ) < 2:
            raise IndexError( "no masks to pop" )
        
        # restore saved state from stack
        self._context.restore()

        # pop last origin offset and restore offsets and mask size
        (x0, y0), (x1, y1) = self._offset_stack.pop()
        self._offset = self._offset[0] - x0, self._offset[1] - y0
        (x0, y0), (x1, y1) = self._offset_stack[-1]
        self._mask_size = x1 - x0, y1 - y0

    @staticmethod
    def _vet_control_points( x0, y0, x1, y1 ):
        # return true if all four control points are given, false if none
        # are given and raise a value error if partial list is given
        # if control points are given generate bezier curve
        if( (x0 is None) and (y0 is None) and
            (x1 is None) and (y1 is None) ):
            return False
        
        if( (x0 is None) or (y0 is None) or
            (x1 is None) or (y1 is None) ):
            raise ValueError(
                "can't generate path: some but not all control points given" )

        return True

    ###
    ### private getter and setter methods for brush properties
    ###

    def _set_color( self, rgba ):
        self._context.set_source_rgba( *rgba )

    def _get_color( self ):
        raise NotImplementedError()

    def _set_pattern( self, pattern ):
        raise NotImplementedError()

    def _get_pattern( self ):
        raise NotImplementedError()

    def _set_size( self, pixels ):
        self._context.set_line_width( pixels )

    def _get_size( self ):
        return self._context.get_line_width()

    def _set_shape( self, square=True ):
        raise NotImplementedError()

    def _get_shape( self ):
        raise NotImplementedError()

    def _get_text( self ):
        return _layout.get_text()
    
    def _set_text( self, string ):
        self._layout.set_text( string )

    def _get_text( self ):
        return self._layout.get_text()

    def _set_font( self, name ):
        raise NotImplementedError()

    def _get_font( self ):
        raise NotImplementedError()

    def _set_font_family( self, family ):
        self._font.set_family( family )
        self._layout.set_font_description( self._font )

    def _get_font_family( self, family ):
        return self._font.get_family()

    def _set_font_weight( self, weight ):
        self._font.set_weight( int(weight * 800) + 100 )
        self._layout.set_font_description( self._font )

    def _get_font_weight( self, family ):
        return (self._font.get_weight() - 100) / 800.0

    def _set_font_size( self, px ):
        self._font.set_size( px * pango.SCALE )
        self._layout.set_font_description( self._font )

    def _get_font_size( self ):
        return self._font.get_size() / pango.SCALE

    def _get_text_size( self ):
        return self._layout.get_pixel_size()

    def _get_position( self ):
        return self._context.get_current_point()
    
    @property
    def mask_size(self):
        """(width, height) of current drawing area mask
        """
        return self._mask_size

    ###
    ### properties for accessing brush attributes
    ###

    color = property( _get_color, _set_color,
                      doc="brush color to use for stroke and fill" )
    pattern = property( _get_pattern, _set_pattern,
                        doc="pattern to use for stroke and fill" )
    size = property( _get_size, _set_size,
                     doc="diameter of brush in pixels" )
    shape = property( _get_shape, _set_shape,
                      doc="shape of brush, Brush.SQUARE or Brush.ROUND" )
    text = property( _get_text, _set_text,
                     doc="text to use for text path" )
    text_size = property( _get_text_size,
                          doc="(width, height) of current text" )
    font = property( _get_font, _set_font,
                     doc="font to use to generate font paths" )
    font_size = property( _get_font_size, _set_font_size,
                          doc="font size to use to generate font paths" )
    font_family = property( _get_font_family, _set_font_family,
                          doc="family can be sans | serif | mono" )
    font_weight = property( _get_font_weight, _set_font_weight,
                          doc="font weight in range 0.0-1.0" )
    position = property( _get_position,
                         doc="current brush position" )

